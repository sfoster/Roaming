<!DOCTYPE html>
<html>
<head>
  <title>Region Test</title>

  <script src="./vendor/require.js"></script>
  <script src="./config.js"></script>

  <style type="text/css">
    #region-id {
      font-style: italic;
      vertical-align: text-top;
      cursor: pointer;
    }
    #region-id:before {
      display: inline-block;
      content: "\25B6";
      font-size: 0.5em;
      vertical-align: middle;
      padding: 0 0.5em 0.3em;
    }
    #region-id.showing:before {
      content: "\25BC";
    }
    #region-raw-data {
      display: none;
      position: absolute;
      width: 400px;
      height: 400px;
      overflow: auto;
      padding: 5px 10px;
      background-color: #eee;
      font-family: monospace;
    }
    #region-raw-data.showing {
      display: block;
    }
  </style>
  <script type="text/javascript">
    var regionId = config.region || 'test';

    require([
      'lib/util',
      'lib/resolve',
      'resources/location',
      'resources/item',
      'resources/encounter',
      'resources/template'
    ],function(util, resolve, Tile, Item, Encounter, template) {

      function trim(str) {
        // TODO: make sure we have a shim
        return str.trim();
      }
      function pluck(ar, p) {
        return ar.map(function(item){
          return item[p];
        });
      }

      var colors = {
        'abyss': 'rgba(51,51,51,1)',
        'mountains': 'rgba(153,153,153,1)',
        'plains': 'rgba(153,255,153,1)',
        'forest': 'rgba(0,153,0,1)',
        'water': 'rgba(51,51,204,1)',
        'barren': 'rgba(204,204,180,1)',
        'marsh': 'rgba(51,204,51,1)',
        'default': 'rgba(51,51,155,1)'
      };

      var TILE_SIZE = 20,
          APRON_SIZE = 1,
          regionWidth, regionHeight;

      function drawAxes() {
        var layer = [
          { assign: 'fillStyle', value: 'rgba(51,51,51,0.5)' },
          // top top x axis
          { call: 'fillRect', value: [0, 0, regionWidth, 12] },
          { call: 'fillRect', value: [0, 0, 12, regionHeight] },
          { assign: 'fillStyle', value: "#fff" },
          { assign: 'font', value: 'normal 8px sans-serif' },
        ];
        for(var i=0; i<=regionWidth/TILE_SIZE; i++) {
          layer.push({ call: 'fillText', value: [ i, i*TILE_SIZE, 0, TILE_SIZE ] });
        }
        for(var i=1; i<=regionHeight/TILE_SIZE; i++) {
          layer.push({ call: 'fillText', value: [ i, 0, i*TILE_SIZE, TILE_SIZE ] });
        }
        return layer;
      }
      var loadingLabel = [
             { assign: 'fillStyle', value: 'rgba(51,51,51,0.5)' },
             { call: 'fillRect', value: [0, 0, 50, 12] },
             { assign: 'fillStyle', value: "#ffc" },
             { assign: 'textBaseline', value: 'top' },
             { assign: 'font', value: 'normal 8px sans-serif' },
             { call: 'fillText', value: [ "loading", 1, 3 ] }
           ];

      var terrainMap = [
        { call: 'clearRect', value: [0, 0,  regionWidth, regionHeight]},
        { assign: 'textBaseline', value: 'top' },
        { assign: 'font', value: 'normal 9px sans-serif' },
        { assign: 'strokeStyle', value: '#000' },
        { assign: 'lineWidth', value: 1 }
      ];

      function createGridFromTilesArray(tiles) {
        console.assert(tiles.length, 'empty tile stubs array passed to createGridFromTilesArray');
        var grid = {};
        var columnCount, rowCount;
        var rows = [], currRow, currY;
        tiles.forEach(function(tile) {
          grid[tile.id] = tile;
          if (tile.y !== currY) {
            currRow = [];
            currY = tile.y;
            rows.push(currRow);
          }
          currRow.push(tile);
        });
        Object.defineProperty(grid, "tiles", { value: tiles, enumerable: false });
        Object.defineProperty(grid, "rows", { value: rows });
        Object.defineProperty(grid, 'rowCount', { value: rows.length });
        Object.defineProperty(grid, 'columnCount', { value: rows[0].length });
        Object.defineProperty(grid, 'length', { value: tiles.length })
        console.assert(grid.length % grid.columnCount == 0,
                      'tiles appear to be uneven grid based on '+grid.columnCount+' columns');
        return grid;
      }

      var ui = {
        tiles: [],
        mapRenderlayers: [
          loadingLabel
        ],
        getSimulatedTilesFromGrid: function(grid, centerX, centerY, apronSize) {
          var minX = Math.max(0, centerX - apronSize),
              minY = Math.max(0, centerY - apronSize);
          var maxX = Math.min(centerX + apronSize, grid.columnCount -1);
          var maxY = Math.min(centerY + apronSize, grid.rowCount -1);
          var sliceSize = 1 + (2 * apronSize);

          var simIDs = [];
          // grab the surrounding tiles
          for(var y=minY; y<=maxY; y++) {
            for(var x=minX; x<=maxX; x++) {
              simIDs.push(grid.tiles[y * grid.columnCount + x]);
            }
          }
          return simIDs;
        },
        init: function(region) {
          var regionId = this.id = region.id;
          document.getElementById('region-id').innerHTML = regionId;
          document.getElementById('region-id').addEventListener('click', this);

          var tileid = config.tileid || '1,1';
          var xy = tileid.split(',').map(function(val) {
            return parseInt(val);
          });
          var currX = xy[0], currY = xy[1];
          console.log('init with region: ', region, 'tileid: ', tileid);
          var stubs = region.tiles.map(function(stub){
            stub.id = stub.x+','+stub.y;
            stub.terrain = stub.type;
            stub.regionId = regionId;
            return stub;
          });
          var grid = this.grid = createGridFromTilesArray(stubs);
          console.log('got grid: ', grid);
          var simGrid = createGridFromTilesArray(
            this.getSimulatedTilesFromGrid(grid, currX, currY, APRON_SIZE)
          );

          grid.tiles.forEach(function(tile){
            var scale = TILE_SIZE, x = scale*tile.x, y = scale*tile.y;
            console.assert(tile.terrain && tile.terrain in colors, tile.terrain + " is a valid color");

            terrainMap.push(
              { assign: 'strokeStyle', value: '#000' },
              { assign: 'fillStyle', value: colors[tile.terrain] || colors[tile['default']] },
              { call: 'fillRect', value: [x, y, scale, scale] },
              { call: 'strokeRect', value: [x, y, scale, scale] }
              // { assign: 'fillStyle', value: "#fff" },
              // { call: 'fillText', value: [ tile.id + ': ' + tile.terrain, 3+x, 3+y ] }
            );
            // TODO: also, load the image indicated and paint that in
            if (simGrid[tile.id]) {
              terrainMap.push(
                {
                  assign: 'fillStyle',
                  value: (currX == tile.x && currY == tile.y) ?
                         'rgba(255,51,51,1)' : 'rgba(255,204,102,1)'
                },
                { call: 'fillRect', value: [x + 0.5*TILE_SIZE, y + 0.5*TILE_SIZE, 3, 3] }
              )
            }
          });

          this.registerEvents();
          this.setupCanvas(region);
          this.updateMapRenderLayers([ terrainMap, drawAxes() ]);

          Promise.all(simGrid.tiles.map(function(stub) {
            // resolve stub to actual location entity
            var resourceId = 'location/' + regionId + '/' + stub.id;
            return resolve.resolveResource(resourceId).then(function(locn) {
              // console.log('resolve location: ', resourceId, locn);
              locn = util.mixin(stub, locn);
              locn = Tile.fillDefaults(locn);
              locn.here.forEach(function(item) {
                Item.fillDefaults(item);
              });
              locn.encounters.forEach(function(item) {
                Encounter.fillDefaults(item);
              });
              return locn;
              // locn.npcs.forEach(function(item) {
              //   Item.fillDefaults(item);
              // });
            });
          })).then(function(locations, idx) {
            this.tiles = locations;
            this.updateTiles();
          }.bind(this));
        },
        registerEvents: function() {
          document.getElementById('mapCanvas')
            .addEventListener('click', this);
        },
        handleEvent: function(evt) {
          if('click' == evt.type) {
            switch(evt.target.id) {
              case 'mapCanvas':
                return this.onMapClick(ui, evt);
              case 'region-id':
                return this.toggleRawData(ui, evt);
            }
          }
        },
        setupCanvas: function (region) {
          regionWidth = TILE_SIZE * (1+pluck(region.tiles, 'x').reduce(function(a, b){
            return Math.max(a, b);
          })),
          regionHeight = TILE_SIZE * (1+pluck(region.tiles, 'y').reduce(function(a, b){
            return Math.max(a, b);
          }));
          console.log("regionWidth: %s, regionHeight: %s", regionWidth, regionHeight);

          var canvasNode = document.getElementById('mapCanvas');
          canvasNode.width = regionWidth;
          canvasNode.height = regionHeight;
          canvasNode.style.width = regionWidth+'px';
          canvasNode.style.height = regionHeight+'px';
        },
        onMapClick: function(vm, evt){
          console.log("Click: ", evt);
          var x = evt.pageX - evt.target.offsetLeft,
              y = evt.pageY - evt.target.offsetTop;
          var tile_x = Math.floor(x / TILE_SIZE),
              tile_y = Math.floor(y / TILE_SIZE);
          console.log("tile size: %s, x: %s, y: %s, tile x: %s, tile y: %s", TILE_SIZE, x, y, tile_x, tile_y);

          var hn = document.getElementById('jump_' + tile_x+','+tile_y);
          if(hn){
            hn.scrollIntoView();
          }
          // location.href = '?location='+region.id+'/'+tile_x+','+tile_y;
        },
        updateMapRenderLayers: function(layers) {
          var ctx = document.getElementById('mapCanvas').getContext('2d');
          layers.forEach(function(instructions){
            instructions.forEach(function(instruct){
              if(instruct.assign) {
                ctx[instruct.assign] = instruct.value;
              } else if(instruct.call) {
                // TODO: maybe require the value to always be an array to optimize a little here
                ctx[instruct.call].apply(ctx, instruct.value instanceof Array ? instruct.value : [instruct.value]);
              }
            });
          });
        },
        updateTiles: function() {
          var tiles = this.tiles;
          var itemTemplate = trim(document.getElementById('itemTemplate').innerHTML);
          itemTemplate = template(itemTemplate);
          var tileTemplate = trim(document.getElementById('tileTemplate').innerHTML);
          tileTemplate = template(tileTemplate);

          var container = document.querySelector('#main > ul');
          var tilesHTMLs = tiles.map(function(tile) {
            var hereHTMLs = (tile.here || []).map(function(item) {
              return itemTemplate(item);
            });
            var encounterHTMLs = (tile.encounters || []).map(function(item) {
              return itemTemplate(item);
            });
            var viewModel = util.create(tile, {
              parentId: this.id,
              hereListHTML: hereHTMLs.join('\n'),
              encountersListHTML: encounterHTMLs.join('\n'),
            });
            var tileHTML = tileTemplate(viewModel);
            return tileHTML;
          }, this);
          container.innerHTML = tilesHTMLs.join('\n');
        },
        toggleRawData: function(evt) {
          document.getElementById('region-raw-data').classList.toggle('showing');
          document.getElementById('region-id').classList.toggle('showing');
        }
      };

      resolve.resolveResource('location/' + regionId + '/index').then(function(regionData) {
        console.log('loaded region: ', regionId);
        document.getElementById('region-raw-data').innerHTML = '<pre>'
          + JSON.stringify(regionData, null, 1) + '</pre>';
        ui.init(regionData);

        setTimeout(function(){
          console.log("showing #main");
          document.getElementById("main").style.display = "block";
          console.log("/showing #main");
        }, 0);
      });

      // region.loadTiles(ids).then(function(tiles){
      //   // sanity check that all tiles look good
      //   console.assert(0 === missingIds.length, "Tiles without ids: ", missingIds);
      // });
    });
  </script>
</head>

<body>
  <section id="map">
    <canvas id="mapCanvas" width="400" height="400" data-bind="click: onMapClick" style="width:400px; height: 400px"></canvas>
  </section>
  <section id="main" class="panel" style="display:none">
    <h2>Region: <span id="region-id"></span></h2>
    <div id="region-raw-data"></div>
    <ul></ul>
    <script type="text/template" id="itemTemplate">
      <li><span>{name}</span> (<span>{type}</span>)</li>
    </script>
    <script type="text/template" id="tileTemplate">
      <li>
        <h2>Location:
          <a id="jump_{id}" href="location.html?location={parentId}/{id}">{id}</a></h2>
        <dl>
          <dt>Region:</dt>
          <dd>{regionId}</dd>
          <dt>Terrain:</dt>
          <dd>{terrain}</dd>
          <dt>Description:</dt>
          <dd>{description}</dd>
        </dl>

        <h2>Here</h2>
        <ul data-from="here">
          {hereListHTML}
        </ul>
        <h2>Encounters</h2>
        <ul data-from="encounters">
          {encountersListHTML}
        </ul>
      </li>
    </script>
  </section>

</body>
</html>
