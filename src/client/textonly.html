<!DOCTYPE html>
<html>
<head>
  <title>Region Test</title>

  <script src="./vendor/require.js"></script>
  <script src="./config.js"></script>

  <script type="text/javascript">
  "use strict";
    var locn = config.location || 'test/3,3';
    console.log('config: ', config);
    var [regionId, startTileId] = locn.split('/');
    var APRON_SIZE = 1;
    var VERBOSE = false;

    function coordToId(coord) {
      return `${coord.x},${coord.y}`;
    }

    require([
      'lib/vue',
      'lib/util',
      'lib/resolve',
      'lib/event',
      'lib/grid',
      'resources/location',
      'resources/item',
      'resources/encounter',
      'resources/player',
    ],function(Vue, util, resolve, Evented,
               CoordGrid, Tile, Item, Encounter, Player) {

      window.gPlayer = null;
      window.gRegion = null;
      window.Evented = Evented;

      Promise.all([
        resolve.resolveResource('location/' + regionId + '/index'),
        resolve.resolveResource('location/' + regionId + '/' + startTileId ),
        resolve.resolveResource('player/' + (config.playerid || 'guest')).then(function(playerData) {
          return resolve.resolveObjectProperties(Player.fillDefaults(playerData));
        })
      ]).then(function(results) {
        let [regionData, tileData, player] = results;
        gPlayer = player;
        console.log('loaded region: ', regionId);
        window._rawRegionData = regionData;
        var region = gRegion = initRegion(regionData);
        console.log('loaded player: ', player);
        if (config.location) {
          player.currentCoord = startTileId;
          player.currentRegion = regionId;
        }
        ui.init(region, tileData, player);
      });
      // 'plugins/vendor/json!player/'+(config.playerid || 'guest') + '.json'

      function createSimGrid(tiles) {
        return new CoordGrid(tiles);
      }
      function createRegionGridFromTilesArray(stubs) {
        console.assert(stubs.length, 'empty tile stubs array passed to createRegionGridFromTilesArray');

        var tiles = stubs.map(function(stub) {
          if (!stub.id) {
            stub.id = stub.x+','+stub.y;
            stub.regionId = regionId;
          }
          return stub;
        });
        return new CoordGrid(tiles);
      };

      function isTileStub(tile) {
        return !tile.hasOwnProperty('here');
      }
      var ui = window.regionUI = {
        tiles: [],
        isTileStub: isTileStub,
        getSimulatedTilesFromGrid: function(grid, centerX, centerY, apronSize) {
          console.log('getSimulatedTilesFromGrid: centerX: %s, centerY: %s, apronSize: %s',
                      centerX, centerY, apronSize);
          var minX = Math.max(0, centerX - apronSize),
              minY = Math.max(0, centerY - apronSize);
          var maxX = Math.min(centerX + apronSize, grid.columnCount -1);
          var maxY = Math.min(centerY + apronSize, grid.rowCount -1);
          var sliceSize = 1 + (2 * apronSize);

          var simIDs = [];
          // grab the surrounding tiles
          for(var y=minY; y<=maxY; y++) {
            for(var x=minX; x<=maxX; x++) {
              simIDs.push(grid.atXY(x, y));
            }
          }

          console.log('getSimulatedTilesFromGrid, returning simIDs: ', simIDs.map((obj) => obj.id));
          return simIDs;
        },
        init: function(region, tileData, player) {
          this.region = region;
          var regionId = player.currentRegion || region.id;

          var tileid = player.currentCoord || '1,1';
          console.log('init with region: ' + this.region, 'tileid: ' + tileid);

          function getVMData(tile, extraProps) {
            let res = {};
            for (let key in tile) {
              if (key.startsWith('_')) continue;
              if (key.startsWith('$')) continue;
              if (key == "type") {
                res["tiletype"] = tile[key];
              } else if (key == "id") {
                res["tileid"] = tile[key];
              } else {
                res[key] = tile[key];
              }
            };
            Object.assign(res, extraProps);
            console.log("prepared vmdata: ", res);
            return res;
          }

          this.components = {};
          this.components.pageheader = Vue.component("pageheader", {
            beforeCreate: function() {
              console.log("beforeCreate, this: ", this);
            },
            template: '<h2>{{region}} / <span id="tile-coord">{{coord}}</span>, {{terrain}}</h2>',
            props: {
              regionId: String
            },
            computed: {
              region: function() {
                return this.$parent.regionId;
              },
              coord: function() {
                return this.$parent.id;
              },
              terrain: function() {
                return this.$parent.terrain;
              },
              description: function() {
                return this.$parent.description;
              }
            },
            created: function() {
              Evented && Evented.on("tilechange", this.tileChange);
            },
            methods: {
              tileChange: function(event) {
                let tile = event.data;
                console.log("header regionChange handler:", event);
                for (let key in this._data) {
                  if (tile.hasOwnProperty(key)) {
                    this[key] = tile[key];
                    console.log("updated " + key, this[key]);
                  }
                }
              }
            }
          });
          console.log("Defined pageheader");

          // register the tile components
          this.components.tile = Vue.component("tile", {
            template: '#tileTemplate',
            props: {
                'tileid' : String,
                'tiletype' : String,
                'regionId' : String,
                'terrain': { type: String, required: false, default: 'not defined' },
                'description': { type: String, required: false, default: 'not defined' },
            },
            data: function() {
              return { parentId: this.regionId }
            },
            created: function() {
              console.log("tile instance created: ", this);
            },
            methods: {
              update: function() {
                this.parentId = "Updated parentId";
                this.id = "Updated id";
              }
            },
            computed: {
              tileHref: function() {
                return `location.html?location=${this.regionId}/${this.id}`;
              },
              jumpId: function() {
                return 'jump_' + this.id;
              }
            },
          });
          console.log('defined components.tile: ', this.components.tile);

         // create the grid structure for the whole region,
          // using the stub data we get from the region/index.
          this.regionGrid = region.grid;
          this.player = player;
          this.player.currentRegion = regionId;

          var tile = this.regionGrid.byId(tileid);
          if (!tile) {
            throw new Error("No tile at: " + tileid);
          }

          let { headerComponent, tileComponent } = this.components;
          window.vm = new Vue({
            name: 'App',
            el: '#view-root',
            components: { headerComponent, tileComponent },
            data: getVMData(tile, { regionId }),
            created: function() {
              console.log("root vue: ", this);
            },
            methods: {
              help: function() {
                console.info('Available actions: ');
                for (let i in actions) {
                  if (i.startsWith('_')) continue;
                  console.info(`actions.${i}()`);
                }
              },
            }
          });

          // TODO: this is effectively our route entry point
          // it takes a string tileid (route)
          // loads it (calls update()) and then renders the resulting state
          this.centerOnTile(tileid).then(() => {
            this.registerEvents();
            window.vm.help();
          });
        },
        update: function() {
          var grid = this.regionGrid;
          var currX = this._currentTile.x,
              currY = this._currentTile.y;
          var simTiles = this.getSimulatedTilesFromGrid(grid, currX, currY, APRON_SIZE)
          var simGrid = this.simGrid = new CoordGrid(simTiles);

          var simGrid = this.simGrid;
          var loadPromises = [];
          VERBOSE && console.log('update entries loop');
          grid.entries.forEach(function(stub, idx) {
            if (simGrid.byId(stub.id)) {
              VERBOSE && console.log('update entries loop, sim id: %s, is stub? %s', stub.id, isTileStub(stub));
              if (isTileStub(stub)) {
                // resolve stub to actual location entity
                VERBOSE && console.log('tile %s in sim area, needs loading', stub.id);
                var resourceId = 'location/' + regionId + '/' + stub.id;
                var frozenStub = JSON.stringify(stub);
                var promise = resolve.resolveResource(resourceId).then(function(locn) {
                  // console.log('resolve location: ', resourceId, locn);
                  VERBOSE && console.log('update entries loop, stub loaded, save frozen stub: ', stub.id, stub);
                  locn._stub = frozenStub;
                  locn = Tile.fillDefaults(locn);
                  locn.here.forEach(function(item) {
                    Item.fillDefaults(item);
                  });
                  locn.encounters.forEach(function(item) {
                    Encounter.fillDefaults(item);
                  });
                  locn = simGrid.updateEntry(locn);
                  return locn;
                  // locn.npcs.forEach(function(item) {
                  //   Item.fillDefaults(item);
                  // });
                });
                loadPromises.push(promise);
              } else {
                // already loaded, leave it
                VERBOSE && console.log('tile %s in sim area, but is already loaded', stub.id);
              }
            } else {
              if (isTileStub(stub)) {
                VERBOSE && console.log('tile %s outside sim area, is stub', stub.id);
                // leave it
              } else {
                // unload it and restore the stub
                VERBOSE && console.log('tile %s loaded but now falls outside sim area', stub.id, stub._stub);
                grid.updateEntry(JSON.parse(stub._stub));
                console.log('updated grid entry:', grid.byId(stub.id));
              }
            }
          });
          return Promise.all(loadPromises);
        },

        render: function() {
          // render the grid to the map canvas
          console.log('render');
          var grid = this.regionGrid;
          var simGrid = this.simGrid;
          var currX = this._currentTile.x,
              currY = this._currentTile.y;
          var tileid = currX+','+currY;
          // TODO: update top vm with current tile data
        },
        centerOnTile: function(tileid) {
          console.log('centerOnTile: %s', tileid);
          var xy = tileid.split(',').map(function(val) {
            return parseInt(val);
          });
          var currX = xy[0], currY = xy[1];
          var grid = this.regionGrid;
          console.log('got grid: ', grid);
          this._currentTile = { x: xy[0], y: xy[1] };
          this.player.currentCoord = this._currentTile;
          console.log('centerOnTile, updated currentCoord: ', this.player.currentCoord);

          var loaded = this.update();
          console.log("call initial render");
          this.render();
          return loaded.then(function() {
            console.log("call loaded render");
            this.render();
            vm.help();
          }.bind(this));
        },

        registerEvents: function() {
        },
        handleEvent: function(evt) {
        },
        updateTiles: function() {
        },
      };

      var actions = window.actions = {
        _goTo: function(deltaX, deltaY) {
          var nextId = [
            gPlayer.currentCoord.x + deltaX,
            gPlayer.currentCoord.y + deltaY
          ].join(',');
          var nextTile = gRegion.grid.byId(nextId);
          if (nextTile) {
            ui.centerOnTile(nextTile.id);
          } else {
            console.warn('Cant go to: ', nextId);
          }
        },
        inspectTile: function(id) {
          id = id || coordToId(ui.player.currentCoord);
          var tile = ui.simGrid.byId(id);
          if (tile) {
            console.log("tile %s is simulated:", id, tile);
          } else {
            console.log("tile %s is not simulated:", id, ui.regionGrid.byId(id));
          }
          console.log( id ? ui.regionGrid[id] : ui.player.currentCoord);
        },
        goNorth: function() {
          this._goTo(0, -1);
        },
        goEast: function() {
          this._goTo(1, 0);
        },
        goWest: function() {
          this._goTo(-1, 0);
        },
        goSouth: function() {
          this._goTo(0, 1);
        }
      };
      function initRegion(region) {
        region.grid = createRegionGridFromTilesArray(region.tiles);
        window.Vue = Vue;
        return region;
      }
    });
  </script>
</head>

<body>
  <section id="view-root">
    <h2 is="pageheader" ref="theHeader"></h2>
    <div id="region-raw-data"></div>
    <div is="tile" ref="theTile"
      v-bind:region-id="regionId"
      v-bind:tileid="tileid"
      v-bind:tiletype="tileid"
      v-bind:terrain="terrain"
      v-bind:description="description"
      ></div>
    <div></div><!--  is="rm-tile" v-bind="tile" -->
  </section>

  <script type="text/x-template" id="tileTemplate">
    <li>
      <h2>Location:
        <a v-bind:id="jumpId" v-bind:href="tileHref">{{regionId}} : {{tileid}}</a></h2>
      <dl>
        <dt>Terrain: </dt>
        <dd>{{terrain}}</dd>
        <dt>Type: </dt>
        <dd>{{tiletype}}</dd>
      </dl>
    </li>
  </script>

</body>
</html>
