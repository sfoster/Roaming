<!DOCTYPE html>
<html>
<head>
  <title>Region Test</title>

  <style>
    body, html {
      padding: 0;
      margin: 0;
      width: 100%;
      height: 100%;
      display: flex;
    }
    #view-root {
      flex: 1 1 auto;
      display: flex;
    }
    #view-root > header {

    }
    #view-root > section {
      flex: 1 1 auto;
      display: flex;
      justify-content: center;
    }
    .player {
      flex: 1 1 auto;
      padding: 10px;
    }
    .player > .avatar {
      width: 10em;
    }
    .player > .stats > li > span:first-child::after {
      content: ":"
    }
    .theTile {
      flex: 5 1 auto;
      padding: 10px;
      text-shadow: 0 0 .4em white;
      background-size: contain;
    }
    .theTile > dl {
      max-width: 45em;
      background-color: rgba(255,255,255,0.5);
      border-radius: 10px;
    }
    .theTile > dl > dt {
      margin: 0 0.5em;
      padding: 0.75em 1em;
    }
    .theTile > dl > dd {
      margin: 0;
      padding: 0.1em 0 0.5em 2.5em;
    }
    .loading {
      opacity: 0.6;
    }
    #loading-message {
      display: none;
    }
    .loading > #loading-message {
      display: block;
    }
  </style>
  <script src="./vendor/require.js"></script>
  <script src="./config.js"></script>

  <script type="text/javascript">
  "use strict";
    var locn = config.location || 'test/3,3';
    var playerid = config.playerid || 'aragon'; // or 'guest'
    console.log('config: ', config);
    var [regionId, startTileId] = locn.split('/');
    var APRON_SIZE = 1;
    var VERBOSE = false;

    function coordToId(coord) {
      return `${coord.x},${coord.y}`;
    }

    require([
      'lib/vue',
      'lib/util',
      'lib/resolve',
      'lib/event',
      'lib/grid',
      'level',
    ],function(Vue, util, resolve, Evented, CoordGrid, Level) {

      let {Tile, Item, Encounter, Player, Terrain} = Level.resources;
      window.gPlayer = null;
      window.gRegion = null;
      window.Evented = Evented;

      Promise.all([
        resolve.resolveResource('location/' + regionId + '/index'),
        resolve.resolveResource('location/' + regionId + '/' + startTileId ),
        resolve.resolveResource('player/' + playerid).then(function(playerData) {
          return resolve.resolveObjectProperties(Player.fillDefaults(playerData));
        })
      ]).then(function(results) {
        let [regionData, tileData, player] = results;
        gPlayer = player;
        window._rawRegionData = regionData;
        var region = gRegion = initRegion(regionData);
        if (config.location) {
          player.currentCoord = startTileId;
          player.currentRegion = regionId;
        }
        ui.init(region, tileData, player);
      });

      function createRegionGridFromTilesArray(stubs) {
        console.assert(stubs.length, 'empty tile stubs array passed to createRegionGridFromTilesArray');

        var tiles = stubs.map(function(stub) {
          if (!stub.id) {
            stub.id = stub.x+','+stub.y;
            stub.regionId = regionId;
          }
          return stub;
        });
        return new CoordGrid(tiles);
      };

      function isTileStub(tile) {
        return !tile.hasOwnProperty('here');
      }

      // register the Vue components
      var pageheaderComponent = Vue.component(
        "pageheader", Level.components.screenHeader);
      var tileComponent = Vue.component(
        "tile", Level.components.tileSummary);
      var playerSummaryComponent = Vue.component(
        "player", Level.components.playerSummary);
      console.log('defined components.tile: ', tileComponent);

      var ui = window.regionUI = {
        tiles: [],
        isTileStub: isTileStub,
        getSimulatedTilesFromGrid: function(grid, centerX, centerY, apronSize) {
          console.log('getSimulatedTilesFromGrid: centerX: %s, centerY: %s, apronSize: %s',
                      centerX, centerY, apronSize);
          var minX = Math.max(0, centerX - apronSize),
              minY = Math.max(0, centerY - apronSize);
          var maxX = Math.min(centerX + apronSize, grid.columnCount -1);
          var maxY = Math.min(centerY + apronSize, grid.rowCount -1);
          var sliceSize = 1 + (2 * apronSize);

          var simIDs = [];
          // grab the surrounding tiles
          for(var y=minY; y<=maxY; y++) {
            for(var x=minX; x<=maxX; x++) {
              simIDs.push(grid.atXY(x, y));
            }
          }

          console.log('getSimulatedTilesFromGrid, returning simIDs: ', simIDs.map((obj) => obj.id));
          return simIDs;
        },
        init: function(region, tileData, player) {
          this.region = region;
          var regionId = this.currentRegionId = player.currentRegion || region.id;
          var tileid = player.currentCoord || '1,1';
          console.log('init with region: ' + this.region, 'tileid: ' + tileid);

         // create the grid structure for the whole region,
          // using the stub data we get from the region/index.
          this.regionGrid = region.grid;
          this.player = player;
          this.player.currentRegion = regionId;

          var tile = this.regionGrid.byId(tileid);
          if (!tile) {
            throw new Error("No tile at: " + tileid);
          }
          this._initRendering();
          // TODO: this is effectively our route entry point
          // it takes a string tileid (route)
          // loads it (calls update()) and then renders the resulting state
          this.centerOnTile(tileid).then(() => {
            this.registerEvents();
            this._viewModel.help();
          });
        },

        _initRendering: function() {
          console.log("ui._initRendering, player: ", this.player);
          window.vm = this._viewModel = new Vue({
            name: 'App',
            el: '#view-root',
            components: {
              pageheaderComponent,
              tileComponent,
              playerSummaryComponent
            },
            data: {
              currentTile: {},
              currentRegionId: ui.currentRegionId,
              tileId: "",
              player: {}
            },
            computed: {
              loaded: function() {
                return (this.currentTile && this.currentTile.id);
              },
              coord: function() {
                if (this.currentTile) {
                  return this.currentTile.id;
                }
                return "-";
              },
              description: function() {
                if (this.currentTile) {
                  return this.currentTile.description;
                }
                return "no description";
              }
            },
            created: function() {
              console.log("root vue: ", this);
            },
            methods: {
              help: function() {
                console.info('some help');
              },
            },
            watch: {
              // someKey: function(value, oldValue) {
              //   console.log("someKey changed: ", value, oldValue);
              // }
            },
            mounted: function() {
              this.$el.classList.add("mounted");
            },
            methods: {
              help: function() {
                console.info('Available actions: ');
                for (let i in actions) {
                  if (i.startsWith('_')) continue;
                  console.info(`actions.${i}()`);
                }
              },
            }
          });
        },

        update: function() {
          var grid = this.regionGrid;
          var currX = this._currentTile.x,
              currY = this._currentTile.y;
          var simTiles = this.getSimulatedTilesFromGrid(grid, currX, currY, APRON_SIZE)
          var simGrid = this.simGrid = new CoordGrid(simTiles);

          var simGrid = this.simGrid;
          var loadPromises = [];
          VERBOSE && console.log('update entries loop');
          grid.entries.forEach(function(stub, idx) {
            if (simGrid.byId(stub.id)) {
              VERBOSE && console.log('update entries loop, sim id: %s, is stub? %s', stub.id, isTileStub(stub));
              if (isTileStub(stub)) {
                // resolve stub to actual location entity
                VERBOSE && console.log('tile %s in sim area, needs loading', stub.id);
                var resourceId = 'location/' + regionId + '/' + stub.id;
                var frozenStub = JSON.stringify(stub);
                var promise = resolve.resolveResource(resourceId).then(function(locn) {
                  // console.log('resolve location: ', resourceId, locn);
                  VERBOSE && console.log('update entries loop, stub loaded, save frozen stub: ', stub.id, stub);
                  locn._stub = frozenStub;
                  locn = Tile.fillDefaults(locn);
                  locn.here.forEach(function(item) {
                    Item.fillDefaults(item);
                  });
                  locn.encounters.forEach(function(item) {
                    Encounter.fillDefaults(item);
                  });
                  locn = simGrid.updateEntry(locn);
                  return locn;
                  // locn.npcs.forEach(function(item) {
                  //   Item.fillDefaults(item);
                  // });
                });
                loadPromises.push(promise);
              } else {
                // already loaded, leave it
                VERBOSE && console.log('tile %s in sim area, but is already loaded', stub.id);
              }
            } else {
              if (isTileStub(stub)) {
                VERBOSE && console.log('tile %s outside sim area, is stub', stub.id);
                // leave it
              } else {
                // unload it and restore the stub
                VERBOSE && console.log('tile %s loaded but now falls outside sim area', stub.id, stub._stub);
                grid.updateEntry(JSON.parse(stub._stub));
                console.log('updated grid entry:', grid.byId(stub.id));
              }
            }
          });
          return Promise.all(loadPromises);
        },

        render: function() {
          // render the grid to the map canvas
          console.log('render, vm: ', this._viewModel);
          // var grid = this.regionGrid;
          var simGrid = this.simGrid;
          var currX = this._currentTile.x,
              currY = this._currentTile.y;
          var tileid = currX+','+currY;
          console.log("updating viewModel with tile, regionId", this._currentTile, ui.currentRegionId);
          var vm = this._viewModel;
          vm.currentTile = simGrid.byId(tileid);
          vm.currentRegionId = ui.currentRegionId;
          if (!(vm.player && vm.player.name)) {
            vm.player = this.player;
          }
        },
        centerOnTile: function(tileid) {
          console.log('centerOnTile: %s', tileid);
          var xy = tileid.split(',').map(function(val) {
            return parseInt(val);
          });
          var currX = xy[0], currY = xy[1];
          var grid = this.regionGrid;
          console.log('got grid: ', grid);
          this._currentTile = { x: xy[0], y: xy[1] };
          this.player.currentCoord = this._currentTile;
          console.log('centerOnTile, updated currentCoord: ', this.player.currentCoord);

          var loaded = this.update();
          return loaded.then(() => {
            console.log("call loaded render");
            this.render();
          });
        },

        registerEvents: function() {
        },
        handleEvent: function(evt) {
        },
        updateTiles: function() {
        },
      };

      var actions = window.actions = {
        _goTo: function(deltaX, deltaY) {
          var nextId = [
            gPlayer.currentCoord.x + deltaX,
            gPlayer.currentCoord.y + deltaY
          ].join(',');
          var nextTile = gRegion.grid.byId(nextId);
          if (nextTile) {
            ui.centerOnTile(nextTile.id);
          } else {
            console.warn('Cant go to: ', nextId);
          }
        },
        inspectTile: function(id) {
          id = id || coordToId(ui.player.currentCoord);
          var tile = ui.simGrid.byId(id);
          if (tile) {
            console.log("tile %s is simulated:", id, tile);
          } else {
            console.log("tile %s is not simulated:", id, ui.regionGrid.byId(id));
          }
          console.log( id ? ui.regionGrid[id] : ui.player.currentCoord);
        },
        goNorth: function() {
          this._goTo(0, -1);
        },
        goEast: function() {
          this._goTo(1, 0);
        },
        goWest: function() {
          this._goTo(-1, 0);
        },
        goSouth: function() {
          this._goTo(0, 1);
        }
      };
      function initRegion(region) {
        region.grid = createRegionGridFromTilesArray(region.tiles);
        window.Vue = Vue;
        return region;
      }
    });
  </script>
</head>

<body>
  <section id="view-root" v-bind:class="{ loading: !loaded }">
    <header>
      <h2 was="pageheader" ref="theHeader"></h2>
    </header>
    <section>
      <section is="player" ref="thePlayer"
             v-bind:player="player"
             class="player"
      ></section>
      <template v-bind:if="loaded">
        <div is="tile" ref="theTile"
             v-bind:tile="currentTile"
             v-bind:region-id="currentRegionId"
        ></div>
      </template>
      <h2 id="loading-message">Loading...</h2>
      <template v-bind:if="!(currentTile && currentTile.id)">
      </template>
    </section>
    <div id="region-raw-data"></div>
  </section>

  <script type="text/x-template" id="tileTemplate">
    <section class="theTile" v-bind:style="tileStyle" v-bind:id="'tile-' + id">
      <h2>Location:
        <a v-bind:id="jumpId" v-bind:href="tileHref">{{regionId}} : {{id}}</a></h2>
      <dl>
        <dt>Terrain: </dt>
        <dd>{{terrain}}</dd>
        <dt>Description: </dt>
        <dd>{{description}}</dd>
      </dl>
    </section>
  </script>

</body>
</html>
